<https://juejin.im/post/6844903871416909837> 

##### 实现方式

```tex
1: 基于数据库 
2: redis 
3: zookeeper实现分布式锁
```

##### 分布式锁应该具备的条件

```tex
1: 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；
2: 高可用的获取锁与释放锁；
3: 高性能的获取锁与释放锁；
4: 具备可重入特性；
5: 具备锁失效机制，防止死锁；
6: 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。
```

##### 基于数据库实现的分布式锁

```tex
	基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含方法名、类名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。	

优缺点：
1： 因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换。
2： 不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁。
3： 没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据。
4： 不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。
在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂。
5：依赖数据库需要一定的资源开销，性能问题需要考虑。

```

##### 基于Redis的实现方式

```tex
1: 选用Redis实现分布式锁原因
	1.1: Redis有很高的性能；
	1.2: Redis命令对此支持较好，实现起来比较方便
2: 实现思想
	2.1: 获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。
	2.2: 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。	
	2.3: 释放锁的时候，若是该锁，则执行delete进行锁释放

```

##### 基于ZooKeeper的实现方式

```tex
1： zookeeper中节点的创建类型有4类，这里我们重点关注下临时顺序节点。这种类型的节点有几下几个特性：
	1.1: 节点的生命周期和客户端会话绑定，即创建节点的客户端会话一旦失效，那么这个节点也会被清除。
	1.2: 每个父节点都会负责维护其子节点创建的先后顺序，并且如果创建的是顺序节点（SEQUENTIAL）的话，父节点会自动为这个节点分配一个整形数值，以后缀的形式自动追加到节点名中，作为这个节点最终的节点名。

2： 实现原理
ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：

2.1： 创建一个目录mylock；
2.2： 线程A想获取锁就在mylock目录下创建临时顺序节点；
2.3： 获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
2.4： 线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
2.5： 线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。
优点
  具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。

####缺点   因为需要频繁的创建和删除节点，性能上不如Redis方式。
```

##### Redis 分布式锁和Zookeeper分布式锁的对比

```tex
	Redis 分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。
	Zookeeper分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。
  单点的redis能很好地实现分布式锁，如果redis集群，会出现master宕机的情况。如果master宕机，此时锁key还没有同步到slave节点上，会出现机器B从新的master上获取到了一个重复的锁；另外一点就是，如果是Redis获取锁的那个客户端出现 bug 挂了，那么只能等待超时时间之后才能释放锁。
  而 Zookeeper的话，因为创建的是临时znode，只要客户端挂了，znode 就没了，此时就自动释放锁。但是zookeeper也会有弊端，那就是有可能会出现“羊群效应”，至于为什么，可以自己百度一下。

什么是羊群效应： https://blog.csdn.net/xubo_zhang/article/details/8506163
	就是zookeeper集群比较大的时候，在whatch监听锁的阶段客户端会受到大量的无用的通知，影响servelt的性能。而这个问题的根源在于，没有找准客户端真正的关注点。
	解决方案： 我们可以只watch比当前我们节点要小的事件通知请求。
```

