<https://www.mscto.com/base/481830.html> 

##### 1： 纠正一些网络上流传的错误说法

```tex
1.1 错误说法一：零拷贝就是零复制或者零拷贝技术没有进行数据的复制操作，所以比较快。

1.2 错误说法二：DMA技术诞生后，零拷贝基于DMA，实现了绝对的零复制…
```

##### 2: 正确理解

```tex
1: 维基百科的解释："Zero-copy" describes computer operations in which the CPU does not perform the task of copying data from one memory area to another.
翻译过来就是说“零拷贝”是指计算机操作的过程中，CPU不需要为数据在内存之间的拷贝消耗资源，这个时候cpu可以干别的事情，至于数据的复制次数只能降低，而不会减少到0（后面会用例子说明）
到这里第一个错误说法就更正了：零拷贝不是指0次复制而是指0次调用CPU消耗资源

2: 并不神秘的DMA
DMA全称是Direct Memory Access，也就是直接存储器访问。它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。通俗点理解，就是让硬件可以跳过CPU的调度，直接访问主内存。
```

##### 3: **操作系统** 

```tex
1: 操作系统  (操作系统是由”硬件”和”软件”两部分组成)
	1.1: 硬件很好理解，以计算机系统为例，计算机硬件包括一个或多个处理器(CPU)、内存、键盘、显示器、磁盘、I/O接口以及其他一些外围设备比如打印机，绘图仪等等。 总之，计算机硬件部分是一个由多种电子和机械设备组成的硬件系统。
	1.2: 软件也可以分为两大类：系统软件和应用软件。工程师们首先直接在硬件上加载一层程序，用它来管理整个计算机硬件设备以及一些软件信息资源，同时还为用户提供开发应用程序的环境，这就是操作系统软件和应用软件。

```

**图例说明**

应用软件是在操作系统支持下，为实现用户要求而编制的各种应用程序。 它们的关系可以概括为下图这样： 

![1592275053674](..\picture\1592275053674.png)

`由于操作系统处于硬件和软件的中央位置，因此我们可以把操作系统称为计算机系统软件的核心，简称核心或内核。 `

##### 4： **用户态和内核态** 

```tex
4.1: 从系统安全和保护的角度出发，在进行计算机体系结构设计时，处理机的执行模式一般设定为两种：分别称为内核模式(内核态)和用户模式(用户态)。
4.2: 这样做可以保护核心代码不受用户程序有意和无意的攻击。可以肯定的是，在系统运行期间需要在内核模式和用户模式之间不断的进行切换。
```

##### 5: **用户空间和内核空间** 

理解了用户态和内核态之后，用户空间和内核空间就可以用一句话概括了：**用户空间就是用户进程所在的内存区域，处于用户态的程序只能访问用户空间；内核空间就是操作系统占据的内存区域，处于内核态的程序可以访问用户空间和内核空间。** 

##### 6: **零拷贝究竟是什么？** 

`6.1: 传统的数据复制使用： 4次数据复制，2次cpu调用。其实基础的read和send也用到了DMA技术，不过这个过程是不消耗cpu的。`

```tex
1: 首先应用程序中调用 read()方法， 这里会涉及到一次上下文切换（用户态->内核态），底层采用DMA技术读取磁盘的文件，并把内容存储到内核空间的读取缓存区。
2： 通过前面的学习，我们知道处于用户空间的应用程序无法读取内核空间的数据，如果应用程序要操作这些数据，必须把这些内容从读取缓冲区拷贝到用户缓冲区。这个时候read()调用返回，且引发一次上下文切换（内核态->用户态）（其实这个时候应用程序可以根据需求操作修改这些内容）
3： 我们最终目的是把这个文件内容通过Socket传到另一个服务中，调用Socket的send()方法，这里又涉及到一次上下文切换（用户态->内核态），再次拷贝到内核地址空间缓冲区，但是这次的缓冲区与目标套接字相关联，与读取缓冲区没有任何关系。
4： send()调用返回，引发第四次的上下文切换，同时进行第四次的数据拷贝，通过DMA把数据从目标套接字相关的缓存区传到相关的协议引擎进行发送。

注意点： 通过上面的详细分析，不难明白，过程1和4是由DMA负责，并不会消耗CPU，只有过程2和3的拷贝需要CPU参与，但是整个过程还是需要进行4次的数据复制。
```

 

![1592275512775](..\picture\1592275512775.png)

`6.2: 优化数据传输流程 `

比如，当我们在应用程序中，不需要操作内容，过程2和3就是多余的，如果可以直接把内核态读取缓存冲区数据直接拷贝到套接字相关的缓存区，就可以起到优化的作用，如下图： 

![1592276025881](..\picture\1592276025881.png)

`经过上图的优化，目前数据的复制次数从4次减少到了3次（2次DMA复制，1次cpu复制），并且上下文的切换次数也从4次减少到了2次。` 

`6.3: 零拷贝成型` 

```tex
我们知道零拷贝粗略来说就是0次CPU调用的意思，那上一小节，还是调用了1次cpu来复制数据，显示还达不到真正的零拷贝，那怎么优化呢？

到这里，如果还想优化，就需要底层网络接口支持收集操作才可以。
所以在Linux 内核 2.4 及后期版本中，工程师们针对套接字缓冲区描述符做了相应调整，使得DMA自带了收集功能，当然对于用户方面，用法还是一样的，但是内部操作已经发生了改变。过程如下图：

这时，数据的传输只需要两步就能搞定：
transferTo() 方法引发 DMA 将文件内容复制到内核读取缓冲区。

把包含数据位置和长度信息的描述符追加到套接字缓冲区，避免了内容整体的拷贝，DMA 引擎直接把数据从内核缓冲区传到协议引擎，全程都是DMA参与，从而消除CPU参与的数据复制消耗。
这样当传输一份数据到一个设备时使用零拷贝技术就可以只对数据复制2次，CPU调用0次，上下文切换2次。

```

![1592276272928](..\picture\1592276272928.png)

##### 7: **总结** 

总体来说，零拷贝是指将数据直接从磁盘文件复制到内核读取缓冲区，然后多个消费者可以共用一个缓冲区，然后DMA  引擎直接把数据从内核读取缓冲区传到消费者，全程都是DMA参与，从而消除CPU参与的数据复制消耗，也不需要经由应用程序之手，减少了内核空间和用户空间之间的上下文切换，同时也大大减少了数据复制的次数。 