##### 1：为什么在项目中使用缓存

```tex
1.1: 高性能
	就是说对于一些需要复杂操作耗时查出来的结果，且确定后面不怎么变化，但是有很多读请求，那么直接将查询出来的结果放在缓存中，后面直接读缓存就好。
1.2：高并发
	mysql 这么重的数据库，压根儿设计不是让你玩儿高并发的，虽然也可以玩儿，但是天然支持不好。mysql 单机支撑到 2000QPS 也开始容易报警了。缓存是走内存的，内存天然就支撑高并发。
	
```

##### 2： 缓存之后的不良后果

```tex
2.1: 缓存数据库双写不一致
2.2：缓存雪崩 缓存击穿 缓存穿透
2.3： 缓存并发竞争
```

##### 3： redis和Memcached有啥区别

```tex
3.1: redis支持更多的数据结构
3.2: redis原生支持集群模式
	在 Redis3.x 版本中，便能支持 cluster 模式，而 Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。
3.3: 性能对比
	由于 Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis。虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。
```

##### 4： redis的线程模型

```tex
Redis 内部使用文件事件处理器 file event handler ，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。
文件事件处理器的结构包含 4 个部分：
1.1: 多个 socket
1.2: IO 多路复用程序
1.3: 文件事件分派器
1.4: 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）
```

##### 5: 为啥redis单线程模型效率还是这么高

```tex
5.1: 纯内存操作
5.2：核心是基于非阻塞的 IO 多路复用机制。
5.3： C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。
5.4： 单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。
```

##### 6： redis过期策略

```tex
Redis 过期策略是：定期删除+惰性删除。
6.1： 定期删除
	指的是 Redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。
问题： 假设 Redis 里放了 10w 个 key，都设置了过期时间，你每隔几百毫秒，就检查 10w 个 key，那 Redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。注意，这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。实际上 Redis 是每隔 100ms 随机抽取一些 key 来检查和删除的。
解决： 但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个 key 的时候，Redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。
# 获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。
但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 Redis 内存块耗尽了，咋整？
答案是：走内存淘汰机制。

6.2： 内存淘汰机制
edis 内存淘汰机制有以下几个：
6.2.1： noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。
6.2.2：allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。
6.2.3： allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。
6.2.4： volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。
6.2.5： volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。
6.2.6： volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。

```

