<https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484239&idx=1&sn=6560be96e456b513cb1e4f78a740a258&chksm=ebd7424edca0cb584906fb97679cf2ca557f430fbc87d2c86ce0652d2e3c36c2528466942df5&scene=21#wechat_redirect> 

##### 一、单例模式概述

```tex
单例模式定义很简单：一个类中能创建一个实例，所以称之为单例！

1: 那我们什么时候会用到单例模式呢？？
    那我们想想既然一个类中只能创建一个实例了，那么可以说这是跟类的状态与对象无关的了。
    频繁创建对象、管理对象是一件耗费资源的事，我们只需要创建一个对象来用就足够了！

2: 那有可能有的人又会想了：我们使用静态类.doSomething()和使用单例对象调用方法的效果是一样的啊。
    没错，效果就是一样的。使用静态类.doSomething()体现的是基于对象，而使用单例设计模式体现的是面向对象。
```

##### 二、编写单例模式的代码

```tex
2.1: 编写单例模式的代码其实很简单，就分了三步：
2.1.1: 将构造函数私有化
2.2.2: 在类的内部创建实例
2.2.3: 提供获取唯一实例的方法
```

##### 2.1饿汉式

```java
public class Java3y {

    // 1.将构造函数私有化，不可以通过new的方式来创建对象
    private Java3y(){}
    // 2.在类的内部创建自行实例
    private static Java3y java3y = new Java3y();

    // 3.提供获取唯一实例的方法
    public static Student getJava3y() {
        return java3y;
    }
}

这种代码我们称之为：“饿汉式”：

一上来就创建对象了，如果该实例从始至终都没被使用过，则会造成内存浪费。
```

##### 2.2简单懒汉式

```java
既然说一上来就创建对象，如果没有用过会造成内存浪费：
那么我们就设计用到的时候再创建对象！
public class Java3y {

    // 1.将构造函数私有化，不可以通过new的方式来创建对象
    private Java3y(){}
    // 2.1先不创建对象，等用到的时候再创建
    private static Java3y java3y = null;

    // 2.1调用到这个方法了，证明是要被用到的了
    public static Java3y getJava3y() {

        // 3. 如果这个对象引用为null，我们就创建并返回出去
        if (java3y == null) {
            java3y = new Java3y();
        }

        return java3y;
    }
}

// 注意点：
上面的代码行不行？？在单线程环境下是行的，在多线程环境下就不行了！
要解决也很简单，我们只要加锁就行了：

```

##### 2.2.1:  简单懒汉式（加锁实现）：

![1594642769362](../picture\1594642769362.png)

##### 2.3双重检测机制(DCL)懒汉式

```java
上面那种直接在方法上加锁的方式其实不够好，因为在方法上加了内置锁在多线程环境下性能会比较低下，所以我们可以将锁的范围缩小。

// 错误版本
public class Java3y {

    private Java3y() {
    }
    private static Java3y java3y = null;
    public static Java3y getJava3y() {
        if (java3y == null) {
            // 将锁的范围缩小，提高性能
            synchronized (Java3y.class) {
                java3y = new Java3y();
            }
        }
        return java3y;
    }
}
那上面的代码可行吗？？不行，因为虽然加了锁，但还是有可能创建出两个对象出来的：

线程A和线程B同时调用getJava3y()方法，他们同时判断java==null，得出的结果都是为null，所以进入了if代码块了

此时线程A得到CPU的控制权-->进入同步代码块-->创建对象-->返回对象
线程A完成了以后，此时线程B得到了CPU的控制权。同样是-->进入同步代码块-->创建对象-->返回对象
很明显的是：Java3y类返回了不止一个实例！所以上面的代码是不行的！

厉害的程序员又想到了：进入同步代码块时再判断一下对象是否存在就稳了吧！
```

