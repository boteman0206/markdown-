## 一般指令

##### man：

``用于查看命令的文档信息 man ls``

##### which:

``查询命令行在哪里 which ls``

##### alias:

``取别名 alias lm = "ls -al"``

##### cp：

```shell
范例：如果指令串太长的话，如何使用两行来输出？
[dmtsai@study ~]$ cp /var/spool/mail/root /etc/crontab \
&gt; /etc/fstab /root
```

**如果一行的数据太长，可以使用 \ 加上 enter 键进行换行输出，换行之后会有 >号出现**

##### echo：

``1： echo $myname 或者 echo ${myname} 获取变量myname的值``

``2： PATH="$PATH":/home/bin”或“PATH=${PATH}:/home/bin” 进行扩容``



##### 设置变量和去除变量

``1设置变量： mayname=world 设置变量的值， 等号两边不能有空格``

``2去除变量：unset myname``

```shell
范例一：设置一变量 name ，且内容为 VBird
[dmtsai@study ~]$ 12name=VBird
bash: 12name=VBird: command not found...  &lt;==屏幕会显示错误！因为不能以数字开头！
[dmtsai@study ~]$ name = VBird            &lt;==还是错误！因为有空白！
[dmtsai@study ~]$ name=VBird              &lt;==OK 的啦！
范例二：承上题，若变量内容为 VBird's name 呢，就是变量内容含有特殊符号时：
[dmtsai@study ~]$ name=VBird's name  
# 单引号与双引号必须要成对，在上面的设置中仅有一个单引号，因此当你按下 enter 后，
# 你还可以继续输入变量内容。这与我们所需要的功能不同，失败啦！
# 记得，失败后要复原请按下 [ctrl]-c 结束！
[dmtsai@study ~]$ name="VBird's name"    &lt;==OK 的啦！
# 指令是由左边向右找→，先遇到的引号先有用，因此如上所示， 单引号变成一般字符！
[dmtsai@study ~]$ name='VBird's name'    &lt;==失败的啦！
# 因为前两个单引号已成对，后面就多了一个不成对的单引号了！因此也就失败了！
[dmtsai@study ~]$ name=VBird\'s\ name     &lt;==OK 的啦！
# 利用反斜线 （\） 跳脱特殊字符，例如单引号与空白键，这也是 OK 的啦！
范例三：我要在 PATH 这个变量当中“累加”:/home/dmtsai/bin 这个目录
[dmtsai@study ~]$ PATH=$PATH:/home/dmtsai/bin
[dmtsai@study ~]$ PATH="$PATH":/home/dmtsai/bin
[dmtsai@study ~]$ PATH=${PATH}:/home/dmtsai/bin
# 上面这三种格式在 PATH 里头的设置都是 OK 的！但是下面的例子就不见得啰！
范例四：承范例三，我要将 name 的内容多出 "yes" 呢？
[dmtsai@study ~]$ name=$nameyes  
# 知道了吧？如果没有双引号，那么变量成了啥？name 的内容是 $nameyes 这个变量！
# 呵呵！我们可没有设置过 nameyes 这个变量呐！所以，应该是下面这样才对！
[dmtsai@study ~]$ name="$name"yes
[dmtsai@study ~]$ name=${name}yes  &lt;==以此例较佳！
范例五：如何让我刚刚设置的 name=VBird 可以用在下个 shell 的程序？
[dmtsai@study ~]$ name=VBird
[dmtsai@study ~]$ bash        &lt;==进入到所谓的子程序
[dmtsai@study ~]$ echo $name  &lt;==子程序：再次的 echo 一下；
       &lt;==嘿嘿！并没有刚刚设置的内容喔！
[dmtsai@study ~]$ exit        &lt;==子程序：离开这个子程序
[dmtsai@study ~]$ export name
[dmtsai@study ~]$ bash        &lt;==进入到所谓的子程序
[dmtsai@study ~]$ echo $name  &lt;==子程序：在此执行！
VBird  &lt;==看吧！出现设置值了！
[dmtsai@study ~]$ exit        &lt;==子程序：离开这个子程序
```



```shell
范例六：如何进入到您目前核心的模块目录？
[dmtsai@study ~]$ cd /lib/modules/`uname -r`/kernel
[dmtsai@study ~]$ cd /lib/modules/$（uname -r）/kernel  # 以此例较佳！
```

- 先进行反单引号内的动作“uname -r”并得到核心版本为 3.10.0-229.el7.x86_64
- 将上述的结果带入原指令，故得指令为：“cd /lib/modules/3.10.0-229.el7.x86_64/kernel/”
- 

##### env 查看环境变量 和 export效果一样

##### set ：观察所有的变量（含环境变量和自订变量）

```shell
[dmtsai@study ~]$ set
BASH=/bin/bash                        &lt;== bash 的主程序放置路径
BASH_VERSINFO=（[0]="4" [1]="2" [2]="46" [3]="1" [4]="release" [5]="x86_64-redhat-linux-gnu"）
BASH_VERSION='4.2.46（1）-release'      &lt;== 这两行是 bash 的版本啊！
COLUMNS=90                            &lt;== 在目前的终端机环境下，使用的字段有几个字符长度
HISTFILE=/home/dmtsai/.bash_history   &lt;== 历史命令记录的放置文件，隐藏文件
HISTFILESIZE=1000                     &lt;== 存起来（与上个变量有关）的文件之指令的最大纪录笔数。
HISTSIZE=1000                         &lt;== 目前环境下，内存中记录的历史命令最大笔数。
IFS=$' \t\n'                          &lt;== 默认的分隔符号
LINES=20                              &lt;== 目前的终端机下的最大行数
MACHTYPE=x86_64-redhat-linux-gnu      &lt;== 安装的机器类型
OSTYPE=linux-gnu                      &lt;== 操作系统的类型！
PS1='[\u@\h \W]\$ '                   &lt;== PS1 就厉害了。这个是命令提示字符，也就是我们常见的
                                          [root@www ~]# 或 [dmtsai ~]$ 的设置值啦！可以更动的！
PS2='&gt; '                              &lt;== 如果你使用跳脱符号 （\） 第二行以后的提示字符也
$                                     &lt;== 目前这个 shell 所使用的 PID
?                                     &lt;== 刚刚执行完指令的回传值。
...
# 有许多可以使用的函数库功能被鸟哥取消啰！请自行查阅！
```







