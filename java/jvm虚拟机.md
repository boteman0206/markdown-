##### 发展历程

```tex
1: hotSpot 热点代码探测 （现在使用最广泛的虚拟机）
2：Jrockit BEA公司（orcle收购）专注于服务端 最快的jvm虚拟机
3：J9 IBM公司 
4： Graal vm 可以兼容所有语言的一款虚拟机（未来发展）
```

##### 内存结构概述

![image-20200722230240871](../picture\image-20200722230240871.png)

##### 类加载子系统的作用

![image-20200722232650691](..\picture\image-20200722232650691.png)

##### 类的加载过程(这个加载指的是广义上的加载过程，和下面的加载步骤是不一样的)

```tex
1：加载 -->:2（链接阶段）： [2.1：验证 --> :2.2：准备 --> 2.3： 解析 ]  -->: 3：初始化

-- 步骤解析：
加载：
	1.1：通过一个类的全限定名获取定义此类的二进制字节流
    1.2：将这个字节流所代表的静态存储结构转换为方法区的运行时的数据结构
    1.3： 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
-- 链接阶段的分类    
验证：
	2.1.1： 目的是在于确保class文件的字节流中包含信息是否符合当前虚拟机的要求，保证被加载类的正确性。 文件格式验证，元数据验证， 字符码校验， 符号引用。
准备阶段（prepare）：
	2.2.1： 为变量分配内存并且设置该类变量的默认初始值
	2.2.2： 这里面不包含final static修饰的，应为final static修饰的会在准备阶段显示的初始化
	2.2.3： 这里不会为实例变量分配初始化，类变量会分配在方法区中， 实例变量随着对象一起初始化到java堆中。
解析：
	2.3.1： 将常量池中的符号转化为直接引用的过程
	2.3.2： 事实上，解析操作往往会伴随着jvm在执行完初始化之后在执行
初始化阶段：
	3.1.1： 初始化阶段就是执行了类的clinit方法的过程
	3.1.2： 此方法不需要定义，是javac编译器自动收集类中的所有类变量和静态代码块的一个合并操作
	3.1.3： jvm保证父类的clinit方法在子类执行前，已经执行完毕
	3.1.4： 虚拟机必须保证一个类的clinit方法在多线程下呗同步加锁， 一个类只呗加载一次

```

##### 类加载器

```tex
1: 启动类加载器（引导类加载器 bootstrap classloader）
	1.1： 这个类由c语言编写负责加载类似于String类等jvm自身需要的类。。。
	1.2： 加载扩展类和应用程序加载器，并指定为他们的父类加载器
	1.3： 没有父类加载器（获取不到 null）
2： 扩展类加载器（extension classloder）
	2.1： java语言表写，派生于classloder类
	2.2： 父类加载器为启动类加载器
3： 引用程序类加载器（系统类加载器 Appclassloder）
	3.1： java语言编写，派生于classloder类
	3.2： 父类加载器为扩展类加载器
	3.3： 通过classloder.getSystemClassLoader()方法可以获取到该类加载器

```

##### 双亲委派机制

```tex
1: 如果一个类加载器收到类加载的请求，他并不会自己先去加载，而是把这个请求委托给谷类的加载器
2： 如果父类加载器还存在其父类加载器，则进一步向上委托，一依次到启动类加载器
3： 如果父类加载器加载成功，则返回，倘若父类无法完成加载，则有应用类加载器或者自定义加载器加载。
```

